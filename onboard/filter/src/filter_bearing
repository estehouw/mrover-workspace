#Postion Filter Logic
    def update_pitch(self):
        '''
        Updates the pitch angle used to correct
        the forward acceleration of the rover
        TODO Correct using g vector
        :return:
        '''
        gyro = self._gyro
        self._pitch += gyro.y * filterconfig.delta_time

    def generate_absolute_acceleration(self):
        """
        Converts the imu data to absolute coordinite system used by the gps
        and corrects for the pitch angle, also updates the z_acceleration
        :return: absolute_accel object containing
        the acceleration in North, East, And Z Directions
        """
        bearing = self._odomf.bearing
        pitch = self._pitch
        raw_imu = self._imu
        north_acc = raw_imu.x * cos(pitch) * sin(90 - bearing)
        east_acc = raw_imu.x * cos(pitch) * cos(90 - bearing)
        z_acc = raw_imu.x * sin(pitch)
        return absolute_accel(north_acc, east_acc, z_acc)

    def decompose_ground_speed(self):
        """
        Breaks the ground speed velocity into
        components aligned with gps coordinate system
        :return: vel object containing the velocity
         in the North, East and Z Directions
        """
        ground_speed = self._gps.ground_speed
        bearing = self._odomf.bearing
        vel_East = ground_speed * cos(90 - bearing)
        vel_North = ground_speed * sin(90 - bearing)
        return absolute_vel(vel_East, vel_North, 0)

    def finalize_velocity(self):
        """
        Combines the ground speed and velocity from
        the imu in a weighted average
        :return: absolute_vel object containing the 
        velocity in the North, East, and Z directions
        """
        ground_speed = self.decompose_ground_speed()
        accel = self.generate_absolute_acceleration()
        old_velocity = self._vel
        vel_North = filterconfig.imu_accel_weight \
            * (old_velocity.x + accel.x * filterconfig.imu_delta_time) \
            + filterconfig.gps_ground_speed_weight * ground_speed.x
        vel_East = filterconfig.imu_accel_weight \
            * (old_velocity.y + accel.y * filterconfig.imu_delta_time) \
            + filterconfig.gps_ground_speed_weight * ground_speed.y
        vel_z = filterconfig.imu_accel_weight \
            * (old_velocity.z + accel.z * filterconfig.imu_delta_time)
        self._vel = absolute_vel(vel_North, vel_East, vel_z)
        return self.vel

    def filter_location(self):
        """
        Combines the gps data with the velocity added
        to the old position in a weighted average
        :return: object containing componenets of final position of the rover
        """
        old_position = self._odomf
        velocity = self.finalize_velocity()
        gps = self._gps

        if not filterconfig.meters_to_longitude_minutes:
            filterconfig.meters_to_longitude_minutes = \
                filterconfig.generate_meters_to_longitude_minutes(gps.lat_deg, gps.lat_min)

        meters_to_longitude_minutes = filterconfig.meters_to_longitude_minutes
        meters_to_latitude_minutes = filterconfig.meters_to_latitude_minutes
        lat_degrees = gps.lat_deg
        lon_degrees = gps.lon_deg

        lat_minutes = old_position.lat.minutes + velocity.north \
            * filterconfig.imu_delta_time * meters_to_latitude_minutes
        lat_degrees += filterconfig.calculated_velocity_weight \
            * (lat_minutes // 60) + filterconfig.gps_loc_weight \
                * gps.lat.degrees
        lat_minutes = filterconfig.calculated_velocity_weight \
            * (lat_minutes % 60) + filterconfig.gps_loc_weight \
                * gps.lat.minutes
        lon_minutes = old_position.lat.minutes + velocity.north \
            * filterconfig.imu_delta_time * meters_to_longitude_minutes
        lon_degrees += filterconfig.calculated_velocity_weight \
            * (lon_minutes // 60) + filterconfig.gps_loc_weight \
                * gps.lon.degrees
        lon_minutes = filterconfig.calculated_velocity_weight \
            * (lon_minutes % 60) + filterconfig.gps_loc_weight \
                 * gps.lon.minutes
        return gps(lat_degrees, lat_minutes, lon_degrees, lon_minutes)

    # Bearing Filter Logic

    def stationary_bearing(self, old_bearing, magnetometer):
        """
        Updates the bearing using an average of the old bearing
         and the value from the magnetometer
        :param old_bearing: previous final bearing value
        :param magnetometer: value from the magnetometer lcm message
        (if we have 2 magnetometers could be averaged)
        :return: the final bearing
        """
        return (old_bearing + magnetometer) / 2

    def turning_bearing(self, old_bearing, gyro, imu_bearing):
        """
        Updates the bearing using a weighted average of gyro derived bearing,
         the old bearing and magnetometer
        :param old_bearing: previous final bearing value
        :param gyro: object containing the components of the gyro lcm message
        :param imu_bearing: degrees from due north
        :return: the final bearing
        """
        return filterconfig.gyro_weight * \
            (old_bearing + gyro.y * filterconfig.delta_time) \
            + filterconfig.imu_bearing_weight * imu_bearing

    def moving_bearing(self, track_angle, imu_bearing):
        """
        Updates the bearing using a weighted average of the
        track angle and magnetometer
        :param track_angle: degrees from due north from gps lcm
        :param imu_bearing: degrees from due north from imu lcm
        :return: the final bearing
        """
        return filterconfig.gps_tracking_angle_weight * track_angle \
            + filterconfig.imu_bearing_weight * imu_bearing

    def finalize_bearing(self, state, imu_bearing, gyro,\
         track_angle, old_bearing):
        """
        Updates the bearing depending on the state of the rover
        :param state: whether the rover is turning,
        stationary, or moving
        :param imu_bearing: degrees from due north
        :param gyro: object containing the data from the gyro lcm
        :param track_angle: degrees from due north from the gps lcm
        :param old_bearing: the previous final bearing
        :return:
        """
        switch = {
            'stationary': self.stationary_bearing,
            'turning': self.turning_bearing,
            'moving': self.moving_bearing
        }

        args = {
            'stationary': [old_bearing, imu_bearing],
            'turning': [old_bearing, gyro, imu_bearing],
            'moving': [track_angle, imu_bearing]
        }
        return switch.get(state, lambda *a: None)(*args.get(state, None))
